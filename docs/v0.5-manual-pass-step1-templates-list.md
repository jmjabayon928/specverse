# Step 1: Templates List Page — Manual Pass Execution Support

**URL:** `/datasheets/templates`  
**Expected:** List renders; filters don’t break; empty state only when truly none exist.

---

## Step 1: What to check (Console)

1. **No red errors**  
   - Any uncaught exception or “Failed to fetch” will appear here.

2. **Optional warnings (non-fatal)**  
   - `Unexpected reference-options payload:` → reference-options response shape wrong (categories/users/disciplines/subtypes).  
   - `Templates fetch returned unexpected payload:` → templates response not an array of template rows.

3. **Filter/empty state**  
   - Filters are client-side only (no extra API calls when changing filters). If the list is empty, check whether the **templates** request returned `[]` (true empty) vs a non-array or error (bug).

---

## Step 1: What to check (Network) + expected endpoint + payload fields

| Request | Method | URL | Expected status | Expected response shape |
|--------|--------|-----|------------------|-------------------------|
| Reference options | GET | `/api/backend/templates/reference-options` | 200 | `{ categories: [...], users: [...], disciplines?: [...], subtypes?: [...] }`. Each category: `CategoryID`, `CategoryName`. Each user: `UserID`, `FirstName`, `LastName`. Each discipline: `id`, `code`, `name`. Each subtype: `id`, `disciplineId`, `code`, `name`. |
| Templates list | GET | `/api/backend/templates` | 200 | Array of objects. Each row: `sheetId`, `sheetName`, `sheetDesc`, `categoryId`, `categoryName`, `preparedById`, `preparedByName`, `revisionDate`, `status`, and optionally `disciplineId`/`disciplineName`, `subtypeId`/`subtypeName`. |

- **Credentials:** Both requests should send `credentials: 'include'` (cookies) so auth works.
- **Order:** Reference-options and templates may run in parallel; both must succeed for list + filters to work.
- **If list is empty:** Inspect the **response body** of `GET /api/backend/templates`. If it is `[]`, DB has no rows with `IsTemplate = 1`. If it is non-200 or non-array, that’s the bug.

---

## Step 1: Backend mapping (controller / service / route)

| Purpose | Route | Handler | Service |
|--------|--------|---------|---------|
| Templates list | GET `/api/backend/templates` | [getAllTemplatesHandler](src/backend/controllers/templateController.ts) | [fetchAllTemplates](src/backend/services/templateService.ts) |
| Reference options (filters) | GET `/api/backend/templates/reference-options` | [getTemplateReferenceOptionsHandler](src/backend/controllers/templateController.ts) | [fetchTemplateReferenceOptions](src/backend/services/templateService.ts) |

- **Middleware:** Both use `verifyToken` and `requirePermission('DATASHEET_VIEW')`. 401/403 here will prevent the handler from running and can yield empty or non-array responses if the client still parses the error body as data.

---

## Step 1: Read-only SQL checks (2–3 queries)

Run these **read-only** to validate what the API should return. Replace `YourDatabase` if your DB name differs.

```sql
-- 1) Row count and sample: templates (what GET /api/backend/templates should return)
USE YourDatabase;  -- or omit if already in context
GO
SELECT COUNT(*) AS TemplateCount
FROM Sheets s
WHERE s.IsTemplate = 1;
GO
SELECT TOP 5
  s.SheetID AS sheetId,
  s.SheetName AS sheetName,
  s.SheetDesc AS sheetDesc,
  s.CategoryID AS categoryId,
  c.CategoryName AS categoryName,
  s.PreparedByID AS preparedById,
  u.FirstName + ' ' + u.LastName AS preparedByName,
  s.RevisionDate AS revisionDate,
  s.Status AS status,
  s.DisciplineID AS disciplineId,
  d.Name AS disciplineName,
  s.SubtypeID AS subtypeId,
  st.Name AS subtypeName
FROM Sheets s
LEFT JOIN Categories c ON s.CategoryID = c.CategoryID
LEFT JOIN Users u ON s.PreparedByID = u.UserID
LEFT JOIN dbo.Disciplines d ON d.DisciplineID = s.DisciplineID
LEFT JOIN dbo.DatasheetSubtypes st ON st.SubtypeID = s.SubtypeID
WHERE s.IsTemplate = 1
ORDER BY s.SheetID DESC;
GO
```

```sql
-- 2) Reference options: categories and users (used by filters)
SELECT COUNT(*) AS CategoryCount FROM Categories;
SELECT COUNT(*) AS UserCount FROM Users;
SELECT TOP 3 CategoryID, CategoryName FROM Categories ORDER BY CategoryName;
SELECT TOP 3 UserID, FirstName, LastName FROM Users ORDER BY FirstName, LastName;
GO
```

```sql
-- 3) Disciplines / subtypes (optional; may be empty if not in schema)
IF EXISTS (SELECT 1 FROM sys.tables WHERE name = 'Disciplines')
  SELECT DisciplineID AS id, Code AS code, Name AS name FROM dbo.Disciplines ORDER BY Name;
IF EXISTS (SELECT 1 FROM sys.tables WHERE name = 'DatasheetSubtypes')
  SELECT SubtypeID AS id, DisciplineID AS disciplineId, Code AS code, Name AS name FROM dbo.DatasheetSubtypes ORDER BY DisciplineID, Name;
GO
```

- If **query 1** returns 0 rows, the list **should** be empty (expected).  
- If **query 1** returns rows but the UI list is empty, the bug is in the API response shape, auth, or client (use Network + Console to see which).  
- If **query 2** fails (e.g. missing tables), reference-options can 500 and filters may not populate.

---

## If failure patterns are detected: what to collect (bug template)

Before planning a fix, collect these so we can match backend behavior:

| Field | What to capture |
|-------|------------------|
| **Page URL** | `https://<host>/datasheets/templates` (or exact path you used). |
| **Steps to reproduce** | e.g. “1. Open /datasheets/templates 2. Observe empty list” or “2. Select category filter → list stays full”. |
| **Console** | Full red error text, or “Unexpected reference-options payload” / “Templates fetch returned unexpected payload” plus the logged payload (truncate if huge). |
| **Network** | For `GET /api/backend/templates` and/or `GET /api/backend/templates/reference-options`: **Status**, **Response body** (JSON). If 401/403/500, copy the `message` / `error` field. |
| **Expected vs actual** | e.g. “Expected: 200 and array of templates. Actual: 200 and []” or “Actual: 500 with message X”. |
| **Server log** | Any line from backend stdout (Node) that corresponds to the request (e.g. error stack from [errorHandler](src/backend/middleware/errorHandler.ts)). |

Then paste the filled bug report; we’ll propose a **minimal-diff fix** and the **best regression test type** (service vs API) and will **not** implement until you’ve pasted the report.
