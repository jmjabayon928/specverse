# SpecVerse v0.5 — E2E Lifecycle Verification Checklist (manual-first)

Manual end-to-end checklist to verify lifecycle correctness for Option A (system vs engineering revision). Grounded in actual routes and behaviors in this repo.

**Reference:** Backend routes in `src/backend/routes/filledSheetRoutes.ts`, `src/backend/routes/templateRoutes.ts`; app pages under `src/app/(admin)/datasheets/`; revision logic in `src/backend/database/sheetRevisionQueries.ts`, `src/backend/services/filledSheetService.ts`, `src/backend/controllers/sheetRevisionController.ts`.

---

## 1) Template create

| Item | Detail |
|------|--------|
| **Route / screen** | App: `/datasheets/templates/create`. API: `POST /api/backend/templates` (createTemplateHandler). |
| **Exact user action** | Fill template metadata and structure (or use builder), submit create. |
| **Expected UI result** | Redirect to template detail (e.g. `/datasheets/templates/[id]`); template appears in list. |
| **Expected DB assertions** | One new row in `Sheets` with `IsTemplate = 1`, `Status = 'Draft'` (or initial status). No `SheetRevisions` row (templates do not use revision snapshots). |
| **SheetRevisions** | **No** new row. Template lifecycle does not touch `SheetRevisions`. |

```sql
-- After create: new template sheet
SELECT SheetID, SheetName, IsTemplate, Status, RevisionNum, RevisionDate
FROM dbo.Sheets WHERE IsTemplate = 1 ORDER BY SheetID DESC;

-- No revisions for templates
SELECT * FROM dbo.SheetRevisions WHERE SheetID = @NewTemplateSheetID;
-- Expect: 0 rows
```

---

## 2) Template approve

| Item | Detail |
|------|--------|
| **Route / screen** | App: `/datasheets/templates/[id]/approve`. API: `POST /api/backend/templates/:id/approve` (approveTemplateHandler). |
| **Exact user action** | Open template approve page, submit approve (or reject). |
| **Expected UI result** | Status updates to Approved (or Rejected); UI reflects new status. |
| **Expected DB assertions** | `Sheets.Status` updated; `ApprovedByID` / `ApprovedByDate` set. No change to `SheetRevisions`. |
| **SheetRevisions** | **No** new row. Approve only updates `Sheets`. |

```sql
SELECT SheetID, Status, ApprovedByID, ApprovedByDate FROM dbo.Sheets WHERE SheetID = @TemplateId AND IsTemplate = 1;
```

---

## 3) Filled create

| Item | Detail |
|------|--------|
| **Route / screen** | App: `/datasheets/filled/create`. API: `POST /api/backend/filledsheets` (createFilledSheetHandler). |
| **Exact user action** | Select template, fill required fields, submit create. |
| **Expected UI result** | Redirect to filled sheet detail (e.g. `/datasheets/filled/[id]`); sheet appears in filled list. |
| **Expected DB assertions** | One new row in `Sheets` with `IsTemplate = 0`, `Status = 'Draft'`. **No** row in `SheetRevisions` at create time. |
| **SheetRevisions** | **No** new row on create. First revision is created on **first save** (update), not on create. |

```sql
-- New filled sheet
SELECT SheetID, SheetName, IsTemplate, Status, RevisionNum, RevisionDate, EngineeringRevision, ClientRevisionCode
FROM dbo.Sheets WHERE SheetID = @NewFilledSheetID AND IsTemplate = 0;

-- No revisions yet
SELECT COUNT(*) AS RevisionCount FROM dbo.SheetRevisions WHERE SheetID = @NewFilledSheetID;
-- Expect: 0
```

---

## 4) Filled edit (values only; STRICT_FILLED_HEADER_GUARD=1)

| Item | Detail |
|------|--------|
| **Route / screen** | App: `/datasheets/filled/[id]/edit`. API: `PUT /api/backend/filledsheets/:id` (updateFilledSheetHandler). |
| **Exact user action** | With `STRICT_FILLED_HEADER_GUARD=1`, change only field values (e.g. subsheet values); do **not** change header fields (sheetName, packageName, revisionNum, revisionDate, etc.). Submit save. |
| **Expected UI result** | Save succeeds; status may move to Modified Draft; UI shows updated values. |
| **Expected DB assertions** | `Sheets` updated (e.g. `Status = 'Modified Draft'`, `ModifiedByID`/`ModifiedByDate`). One new row in `SheetRevisions` (see step 5). If user had changed a header field, request is rejected with 400 and message that header fields are read-only. |
| **SheetRevisions** | **Yes** — one new row created by `updateFilledSheet` when `skipRevisionCreation` is not set (normal save). See step 5. |

**Guard behavior:** Logic in `filledSheetService.updateFilledSheet`: when `allowHeaderUpdate` is false and `process.env.STRICT_FILLED_HEADER_GUARD === '1'`, current header from DB is compared to payload; if any of `FILLED_HEADER_GUARD_FIELDS` (e.g. sheetName, packageName, revisionNum, revisionDate, …) differ, 400 with `headerFieldErrors`. So for this step, only edit values to avoid 400.

```sql
-- After save: Sheet updated
SELECT SheetID, Status, ModifiedByID, ModifiedByDate FROM dbo.Sheets WHERE SheetID = @FilledSheetID;
```

---

## 5) Revision creation (implicit on save)

| Item | Detail |
|------|--------|
| **Route / screen** | Same as step 4: `PUT /api/backend/filledsheets/:id` (updateFilledSheet). Revision is created inside the same transaction as the sheet/values update. |
| **Exact user action** | Any successful filled-sheet save (edit values and submit) that does not use `skipRevisionCreation`. |
| **Expected UI result** | Revisions list (step 6) shows one more revision; revision number increments. |
| **Expected DB assertions** | One new row in `SheetRevisions`: `SystemRevisionNum` = `RevisionNum` = next sequential number; `SystemRevisionAt` and `RevisionDate` set; `SnapshotJson` contains full UnifiedSheet JSON; dual-write consistent. |
| **SheetRevisions** | **Yes** — exactly one new row per save. `createRevision` in `sheetRevisionQueries.ts` is called from `updateFilledSheet` when `!options?.skipRevisionCreation`. |

```sql
-- Option A: dual-write and next number
SELECT RevisionID, SheetID, SystemRevisionNum, SystemRevisionAt, RevisionNum, RevisionDate,
       CreatedByID, CreatedByDate, LEN(SnapshotJson) AS SnapshotLen
FROM dbo.SheetRevisions
WHERE SheetID = @FilledSheetID
ORDER BY COALESCE(SystemRevisionNum, RevisionNum) DESC;

-- Next number = MAX(SystemRevisionNum)+1 (or COALESCE with RevisionNum for legacy nulls)
SELECT ISNULL(MAX(COALESCE(SystemRevisionNum, RevisionNum)), 0) + 1 AS NextNum
FROM dbo.SheetRevisions WHERE SheetID = @FilledSheetID;
```

---

## 6) Revision list ordering (SystemRevisionNum)

| Item | Detail |
|------|--------|
| **Route / screen** | App: `/datasheets/filled/[id]/revisions`. API: `GET /api/backend/filledsheets/:id/revisions?page=1&pageSize=20` (listRevisionsHandler → listRevisionsPaged). |
| **Exact user action** | Open revisions list for a filled sheet. |
| **Expected UI result** | Revisions shown newest first (highest revision number at top). Response includes `revisionNumber`, `systemRevisionNum`, `systemRevisionAt` (additive). |
| **Expected DB assertions** | List is ordered by `COALESCE(SystemRevisionNum, RevisionNum) DESC`. New rows have `SystemRevisionNum` = `RevisionNum`; legacy rows may have NULL `SystemRevisionNum` but still appear in correct order via COALESCE. |
| **SheetRevisions** | No new row. Read-only. |

```sql
-- Same order as API
SELECT RevisionID, SystemRevisionNum, RevisionNum, CreatedByDate
FROM dbo.SheetRevisions
WHERE SheetID = @FilledSheetID
ORDER BY COALESCE(SystemRevisionNum, RevisionNum) DESC;
```

---

## 7) Diff view (client diff; compareTo behavior)

| Item | Detail |
|------|--------|
| **Route / screen** | App: `/datasheets/filled/[id]/revisions/[revisionId]/diff?compareTo=[compareToRevisionId]`. API: `GET /api/backend/filledsheets/:id/revisions/:revisionId` and same for `compareTo` (getRevisionHandler). |
| **Exact user action** | From revisions list, click “Diff vs previous” (navigates with `compareTo` = revisionId of the previous revision by number). Or open diff URL with two valid revision IDs. |
| **Expected UI result** | Diff page shows side-by-side or unified diff of two snapshots (client-side `diffUnifiedSheets` in `src/domain/datasheets/revisionDiff.ts`). If `compareTo` missing or invalid, page shows error that `compareTo` is required. |
| **Expected DB assertions** | Two revision rows exist; both have `SnapshotJson`; ordering is by system revision. No new row created. |
| **SheetRevisions** | No new row. Diff is read-only (two GETs, client-side diff). |

```sql
-- Both revisions exist and have snapshots
SELECT RevisionID, SheetID, SystemRevisionNum, RevisionNum, CASE WHEN SnapshotJson IS NOT NULL AND LEN(SnapshotJson) > 0 THEN 1 ELSE 0 END AS HasSnapshot
FROM dbo.SheetRevisions
WHERE SheetID = @FilledSheetID AND RevisionID IN (@RevisionId, @CompareToRevisionId);
```

---

## 8) Restore revision (must create one new revision row)

| Item | Detail |
|------|--------|
| **Route / screen** | App: `/datasheets/filled/[id]/revisions` → Restore modal; then redirect to `/datasheets/filled/[id]?success=restored`. API: `POST /api/backend/filledsheets/:id/revisions/:revisionId/restore` (restoreRevisionHandler). |
| **Exact user action** | Select a revision, click Restore, optionally add comment, confirm. |
| **Expected UI result** | Success message; redirect to filled sheet detail; sheet content matches restored snapshot; revisions list shows one additional revision (the new “restored” snapshot). |
| **Expected DB assertions** | (1) Sheet and InformationValues (and related) updated to match restored snapshot. (2) **Exactly one** new row in `SheetRevisions`: new `SystemRevisionNum`/`RevisionNum` = previous max + 1; `SnapshotJson` = current sheet state after restore; dual-write. Restore does **not** re-use the old revision ID; it creates a new revision row. |
| **SheetRevisions** | **Yes** — one new row. Flow: `updateFilledSheet(..., { skipRevisionCreation: true })` applies snapshot; then `createRevision(transaction, { snapshotJson: updatedSheet.datasheet, ... })` in a separate transaction. |

```sql
-- Before restore: count
SELECT COUNT(*) AS C FROM dbo.SheetRevisions WHERE SheetID = @FilledSheetID;

-- After restore: count +1; new row has SnapshotJson = restored state
SELECT RevisionID, SystemRevisionNum, RevisionNum, SystemRevisionAt, RevisionDate, LEN(SnapshotJson) AS SnapshotLen
FROM dbo.SheetRevisions
WHERE SheetID = @FilledSheetID
ORDER BY COALESCE(SystemRevisionNum, RevisionNum) DESC;
```

---

## 9) Filled approve (no revision created)

| Item | Detail |
|------|--------|
| **Route / screen** | App: `/datasheets/filled/[id]/approve`. API: `POST /api/backend/filledsheets/:id/approve` (approveFilledSheetHandler). |
| **Exact user action** | Submit approve (or reject) for a filled sheet in Verified status. |
| **Expected UI result** | Status becomes Approved (or Rejected); UI and list reflect new status. |
| **Expected DB assertions** | `Sheets.Status`, `ApprovedByID`, `ApprovedByDate` (or reject fields) updated. **No** new row in `SheetRevisions`. Approve only updates `Sheets`; it does not call `updateFilledSheet` with snapshot or `createRevision`. |
| **SheetRevisions** | **No** new row. |

```sql
SELECT SheetID, Status, ApprovedByID, ApprovedByDate FROM dbo.Sheets WHERE SheetID = @FilledSheetID AND IsTemplate = 0;

SELECT COUNT(*) AS RevisionCountAfterApprove FROM dbo.SheetRevisions WHERE SheetID = @FilledSheetID;
-- Same count as before approve
```

---

## 10) Clone template → filled

| Item | Detail |
|------|--------|
| **Route / screen** | App: `/datasheets/templates/[id]/clone`. API: `POST /api/backend/templates/:id/clone` (cloneTemplateHandler → duplicateSheet or template clone flow). |
| **Exact user action** | Open template clone, submit (with or without edits). |
| **Expected UI result** | New filled sheet created; redirect to new sheet detail. New sheet has structure copied from template; no revision history. |
| **Expected DB assertions** | New row in `Sheets` with `IsTemplate = 0`, `ParentSheetID` = source template, `Status = 'Draft'`, `RevisionNum`/`RevisionDate` set per clone logic (e.g. 1 and today). SubSheets/InformationTemplates copied. **No** rows in `SheetRevisions` for the new sheet until first save. |
| **SheetRevisions** | **No** new row at clone time. First revision on first update (save). |

```sql
SELECT SheetID, IsTemplate, ParentSheetID, Status, RevisionNum, RevisionDate
FROM dbo.Sheets WHERE SheetID = @NewClonedFilledSheetID;

SELECT COUNT(*) FROM dbo.SheetRevisions WHERE SheetID = @NewClonedFilledSheetID;
-- Expect: 0
```

---

## 11) Clone filled → filled

| Item | Detail |
|------|--------|
| **Route / screen** | App: `/datasheets/filled/[id]/clone`. API: `POST /api/backend/filledsheets/:id/clone` (cloneFilledSheetHandler). |
| **Exact user action** | Open filled sheet clone, submit. |
| **Expected UI result** | New filled sheet created; redirect to new sheet; new sheet has copied structure and possibly initial values; no revision history carried over. |
| **Expected DB assertions** | New row in `Sheets` with `IsTemplate = 0`; new sheet has its own SheetID; **no** copy of source sheet’s `SheetRevisions`. Revision history is per sheet; clone creates a new sheet, so revision count for new sheet is 0 until first save. |
| **SheetRevisions** | **No** new row at clone. New sheet gets first revision on first save. |

```sql
SELECT SheetID, IsTemplate, Status FROM dbo.Sheets WHERE SheetID = @NewClonedFilledSheetID;
SELECT COUNT(*) FROM dbo.SheetRevisions WHERE SheetID = @NewClonedFilledSheetID;
-- Expect: 0
```

---

## 12) Export PDF / Excel (revision display)

| Item | Detail |
|------|--------|
| **Route / screen** | Export from filled sheet detail or viewer. API: `GET /api/backend/filledsheets/export/:id/pdf` and `GET /api/backend/filledsheets/export/:id/excel` (exportFilledSheetPDF, exportFilledSheetExcel). |
| **Exact user action** | Trigger PDF or Excel export for a filled sheet (with or without `Sheets.EngineeringRevision` set). |
| **Expected UI result** | Download with filename and header/metadata “Revision” value: (1) if `EngineeringRevision` is set and non-empty, use it for display and filename segment; (2) else use numeric `RevisionNum`. `RevisionDate` unchanged (no new date column). ClientRevisionCode not added to layout in v0.5. |
| **Expected DB assertions** | Export reads sheet via getFilledSheetDetailsById (or equivalent); DTO includes `EngineeringRevision`, `ClientRevisionCode` from `Sheets`. Exports use `getDisplayRevision(sheet)` (or equivalent): `engineeringRevision` when present, else `String(revisionNum)`. |
| **SheetRevisions** | No new row. Export is read-only. |

```sql
-- Sheet has EngineeringRevision when testing “prefer engineering” path
SELECT SheetID, RevisionNum, RevisionDate, EngineeringRevision, ClientRevisionCode
FROM dbo.Sheets WHERE SheetID = @FilledSheetID;
```

**Verification:** For a sheet with `EngineeringRevision = 'Rev-A'`, filename should contain `Rev-A` and header “Revision” should show `Rev-A`. For a sheet with NULL/empty `EngineeringRevision`, filename and header should show numeric `RevisionNum`. `revisionDate` in export should match `Sheets.RevisionDate`.

---

## Option A DB assertions summary

- **Dual-write:** Every new `SheetRevisions` row has `SystemRevisionNum` = `RevisionNum`, `SystemRevisionAt` = timestamp, `RevisionDate` = date part of that timestamp.
- **Next number:** `getNextRevisionNumber` uses `ISNULL(MAX(COALESCE(SystemRevisionNum, RevisionNum)), 0) + 1` with UPDLOCK/HOLDLOCK.
- **SnapshotJson:** Every revision row has `SnapshotJson` populated with full UnifiedSheet JSON after create/update/restore.
- **Exports:** Use `Sheets.EngineeringRevision` when present; otherwise numeric `RevisionNum`; `RevisionDate` unchanged.

---

## Automation hooks later

High-level mapping for future automation; no implementation in this doc.

| Step | Playwright (E2E) | Integration (API/DB) | Stable test data / seed |
|------|------------------|------------------------|---------------------------|
| 1 Template create | Submit create form; assert redirect and template in list. | POST templates; assert Sheets row, no SheetRevisions. | Category, discipline/subtype, optional area/client/project. |
| 2 Template approve | Open approve page; submit; assert status. | POST approve; assert Status, ApprovedBy*. | Template in Verified status. |
| 3 Filled create | Submit create from template; assert redirect. | POST filledsheets; assert Sheets row, 0 SheetRevisions. | Approved template. |
| 4 Filled edit (guard) | Edit only values; save; then (optional) try editing header, expect error. | PUT with header change when STRICT_FILLED_HEADER_GUARD=1; expect 400. | Filled sheet Draft; known subsheet/field IDs. |
| 5 Revision creation | Same as 4; then open revisions list, assert new revision. | After PUT, assert new SheetRevisions row and dual-write. | Filled sheet with 0 or N revisions. |
| 6 List ordering | Open revisions list; assert order (newest first). | GET revisions; assert order matches COALESCE(SystemRevisionNum, RevisionNum) DESC. | Sheet with multiple revisions. |
| 7 Diff view | Click “Diff vs previous”; assert diff page and compareTo. | GET two revisions; assert both have SnapshotJson. | Two consecutive revisions. |
| 8 Restore | Restore a revision; assert success and new revision in list. | POST restore; assert one new SheetRevisions row and SnapshotJson. | Sheet with ≥2 revisions. |
| 9 Filled approve | Submit approve; assert status. | POST approve; assert no new SheetRevisions. | Filled in Verified status. |
| 10 Clone template→filled | Clone template; assert new filled sheet. | POST template clone; assert new Sheets row, 0 SheetRevisions. | Approved template. |
| 11 Clone filled→filled | Clone filled; assert new sheet. | POST filled clone; assert new Sheets row, 0 SheetRevisions for new ID. | Filled sheet. |
| 12 Export | Trigger export; assert filename and (if possible) revision in content. | GET export; parse filename/headers; assert EngineeringRevision vs revisionNum. | Sheet with and without EngineeringRevision set. |

**Stable seed (conceptual):** One approved template, one filled sheet (Draft then after save with ≥2 revisions), one filled sheet with `EngineeringRevision` set. No hardcoded IDs in tests; resolve from seed or create in setup. Environment with `STRICT_FILLED_HEADER_GUARD=1` for step 4 guard tests.
